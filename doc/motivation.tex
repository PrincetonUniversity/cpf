% !TEX root = paper.tex
\section{Background and Motivation}
\label{sec:motivation}

% In this section, we examine the limitations of prior work based on their
% applicability and profitability \{\textbf{XXX} \}.

\subsection{Background}
Software-based automatic parallelization systems have been studied for over
two decades.
%
% Static analysis and runtime analysis are limited
Early works~\cite{blume:94:polaris,suif:94:stanford,rus:03:hybrid} focus on
scientific code and use either static analysis to remove dependences or
run-time analysis to infer if the parallel version of the code is safe to
use. Privatization and reduction are also relied on analysis to remove flow
dependences or prove the reduction property. The drawback of static
analysis is that it is too imprecise to remove enough dependences to enable
parallelization, while run-time analysis predicates can be too complex or
expensive to extract. PD~\cite{rauchwerger:94:ics},
LRPD~~\cite{dang:02:ipdps} introduce
speculative privatization to overcome static analysis' limitations.

More recent works ~\cite{mehrara:09:stmlite,kim:12:cgo,johnson:12:pldi} are
able to use speculation when static analysis is insufficient to remove
dependences. This improves the applicability to loops with pointers and
dynamic data structures.  Among these works, Privateer
~\cite{johnson:12:pldi}, by using heap separation and aggressive
speculation, supports both speculative privatization and reduction even in
the presence of unrestricted pointers, and enables greater applicability
than other speculative parallelization systems.  Yet, applicability doesn't
necessarily translate to parallel performance. The results of automatic
DOALL systems on real hardware are still underwhelming due to the existence
of various overheads.

There have been attempts to reduce overheads.
ClusterDOALL~\cite{kim:12:cgo} and CorD~\cite{ctian:2008:micro} use static
analysis after privatization is applied to remove unnecessary memory
speculation checks. Integrated in Polaris~\cite{blume:94:polaris}, automatic
array privatization\cite{tu:94:lcpc} tries to avoid bookkeeping and merging
overheads specific to privatization. However, for most general purpose
programs, many workloads rely on irregular structures (e.g., trees, graphs,
lists) and static analysis are mostly not applicable to them. We believe
that there are better ways to reduce these overheads further or even
completely remove them in many cases.

\subsection{Overhead Investigation}
Privateer is the state-of-the-art parallelization technique for the
workloads this paper targets. Hence, we started analyzing the overhead of
this technique.
%
Examining the evaluation of Privateer, we spot two major overheads,
excessive use of memory speculation which is general for prior speculative
parallelization systems, and expensive privatization which applies to
most systems with privatization.
%
In the following parts, we investigate the impact of this two main
overheads on Privateer along with a motivating example taken from the
\texttt{dijkstra} benchmark (used in Privateer's evaluation) from MiBench
~\cite{}. A simplified version of this example is shown in Figure
~\ref{fig:dijkstra_motivation}. The reuse of the array
\texttt{\textbf{pathcost}} and global variable \texttt{\textbf{dist}}
causes cross-iteration false dependence(s) that inhibit parallelization.
Privateer removes these dependences by creating private copies of
\texttt{\textbf{pathcost}} and \texttt{\textbf{dist}} for each worker.

\subsubsection{Excessive Use of Memory Speculation}
Privateer's excessive use of memory speculation leads to large overheads
for monitoring reads of and writes to privatized objects, with an average
of 23.7 GB of reads and 18.4 GB of writes monitored per program reported in
the paper. \texttt{dijkstra} has particularly high overheads (84.9GB of
reads and 56.7GB of writes), which limits its speedup to 4.8$\times$ on 24
cores. Privateer uses memory speculation to disprove the cross-iteration
RAW dependence from line \textbf{13} to line \textbf{37} in order to
privatize \texttt{\textbf{dist}}. Since the write to \texttt{\textbf{dist}}
is inside a conditional block, static analysis alone is unable to disprove
this dependence. Current speculative systems, including Privateer, will
first apply memory speculation to this dependence and then perform static
analysis, adding logging and validation (overheads). If, however, we can
use edge profiling to speculate that this conditional statement will always
execute and pass this speculative assumption to the static analysis, this
RAW dependence can be removed with minimal cost, avoiding all monitoring of
reads to this object. This combination is superior to using memory
speculation, as the cost for validating control speculation is negligible
compared to that of memory speculation.

\subsubsection{Expensive Privatization}
Perhaps counterintuitively, benchamrks that do not require memory
speculation still have heavy overhead due to bookkeeping of the write set
due to the inherent nature of privatization. For \texttt{dijkstra}, even
assuming all the private reads are removed, Privateer still need to log
56.8 GB of writes, which constitutes around 20\% of each parallel worker's
time. Apart from this overhead, privatization also introduces the cost of
merging the parallel workers' states during checkpointing. In Figure
~\ref{fig:dijkstra_motivation}, static analysis alone can disprove all RAW
dependences related to \texttt{\textbf{pathcost}} and safely privatize it.
However, because \texttt{\textbf{pathcost}} is a live-out object, i.e.,
might be read after the loop invocation, each write to it requires a log in
order to determine which worker writes each byte of the object. We can
infer, though, that the \texttt{for} loop in lines \textbf{28} and
\textbf{29} will overwrite \texttt{\textbf{pathcost}} at every iteration.
Thus, the live-out values will only come from the last iteration and no
bookkeeping is needed.

\subsection{Motivation}
This work is motivated by the need of reducing significatly the two main
sources of overhead described above, namely the excessive use of memory
speculation and the expensive privatization, of prior speculative systems
that significantly limits their efficiency.
%
In the next section, we will show that by using speculation-aware memory
analyzer in conjuction with efficient privatization under a sensible
planner allows an efficient and scalable automatic parallelization while
maintaining the state-of-the-art applicability.


\lstset{basicstyle=\ttfamily, numbers=left, numberstyle=\tiny,
  stepnumber=1, numbersep=5pt}
\begin{figure}[t]
  \centering
  %\begin{tabular}{cc}
  \scriptsize
%\resizebox{0.8\linewidth}{!}{
    \subfloat{
    \begin{minipage}{5cm}
      \input{figures/dijkstra_motivation}
    \end{minipage}
    }
\caption{Sequential \textit{dijkstra} example from MiBench~\cite{guthaus:2001:iiwsc}}
\label{fig:dijkstra_motivation}
\end{figure}
