\section{Background and Motivation}
\label{sec:motivation}

% In this section, we examine the limitations of prior work based on their
% applicability and profitability \{\textbf{XXX} \}.

\subsection{Background}
Software-based automatic parallelization systems have been studied for over
two decades.
%
Early works
~\cite{blume:96:icpp,suif:94:stanford}
focused on scientific code written in Fortran and lacked support for
dynamic allocation or the complexity of pointers in modern C/C++ codes.
% These works utilize privatization and reduction to create private copies of
% data structures for each parallel worker to eliminate
% cross-iteration memory-related dependences that inhibit parallelization.
These works also do not use speculation and instead rely on either static
analysis to remove dependences or run-time analysis to infer if the
parallel version of the code is safe to use. The drawback of static
analysis is that it is too imprecise to remove enough dependences to enable
parallelization, while run-time analysis predicates can be too complex or
expensive to extract. Later works ~\cite{Rus:07:ics,rus:03:hybrid,rauchwerger:99:pds}
introduce speculation to discover, through profiling, dependences that rarely
manifest at runtime and ignore them to overcome static analysis' limitation;
the cost of using speculation is the added validation and recovery for
guaranteeing correctness.

Privatization and reduction are other ways to remove cross-iteration
write-after-read (WAR) and write-after-write (WAW) dependences that inhibit
parallelization; however, they require that no read-after-write (RAW)
dependences exist to be applicable. Using only static analysis for
dependence removal restricts usage of privatization and reduction to
programs with simple control flows \{\textbf{XXX} Is this accurate?\}.
In addition, these techniques require logging to ensure correct live-out
values are communicated.

More recent works ~\cite{mehrara:09:stmlite,kim:12:cgo,johnson:12:pldi} are
able to use speculation when static analysis is insufficient to enable
privatization or reduction of both statically and dynamically allocated
objects. Privateer ~\cite{johnson:12:pldi} uses aggressive
speculation to allow privatization and reduction to be widely applicable,
even in the presence of unrestricted pointers.
Employing speculation for privatization, however, requires extra validation
that ensures no RAW dependence manifests at runtime. Examining the
evaluation of Privateer, which greedily \{\textbf{XXX} is liberally a
better word in this case?\} uses memory speculation to disprove
dependences, reveals that this method, although widely applicable, indeed
exhibits major overheads both in speculation validation and expensive
privatization logging and checks.

ClusterDOALL ~\cite{kim:12:cgo} and CorD ~\cite{ctian:2008:micro} use
static analysis after privatization is applied to remove unnecessary
speculation checks, while Polaris ~\cite{tu:94:lcpc} includes an array
analysis pass to avoid bookkeeping and merging overheads. However, we
believe \{\textbf{XXX} do we though?\} that there are other ways to reduce
these overheads further or even completely remove them in many cases.

\subsection{Overhead Investigation}
In this section, we investigate the impact of the two main overheads of
Privateer with a code sample taken from the \texttt{dijkstra} benchmark
(used in Privateer's evaluation) from MiBench ~\cite{}, a simplified
version of which is shown in Figure ~\ref{fig:dijkstra_motivation}.
The reuse of the array \texttt{\textbf{pathcost}} and global variable
\texttt{\textbf{dist}} causes cross-iteration false dependence(s) that
inhibit parallelization. Privateer removes these dependences by creating
private copies of \texttt{\textbf{pathcost}} and \texttt{\textbf{dist}}
for each worker.

\subsubsection{Excessive Use of Memory Speculation}
Privateer's excessive use of memory speculation leads to large overheads
for monitoring reads of and writes to privatized objects, with an average
of 23.7 GB of reads and 18.4 GB of writes monitored per program.
\texttt{dijkstra} has particularly high overheads, which limits its speedup
to 4.8$\times$ on 24 cores.
Privateer uses memory speculation to disprove the cross-iteration RAW
dependence from line \textbf{13} to line \textbf{37} in order to privatize
\texttt{\textbf{dist}}. Since the write to \texttt{\textbf{dist}} is inside
a conditional block, static analysis alone is unable to disprove this
dependence. Current speculative systems, including Privateer, will first
apply memory speculation to this dependence and then perform static analysis,
adding logging and validation (overheads). If, however, we can use edge
profiling to speculate that this conditional statement will always execute
and pass this speculative assumption to the static analysis, this RAW
dependence can be removed with minimal cost, avoiding all monitoring of reads to
this object. This combination is superior to using memory speculation,
as the cost for validating control speculation is negligible compared to
that of memory speculation.

\subsubsection{Expensive Privatization}
Perhaps counterintuitively, benchamrks that do not require memory speculation
still have heavy overhead due to bookkeeping of the write set. For the
\texttt{blackscholes} benchmark, Privateer logs 4 GB of writes,
which constitutes 15\% of each parallel worker's time, due to the inherent
nature of privatization and need for the correct live-out value \{\textbf{XXX} Do we
use blackscholes because we don't know how many writes of pathcost there
are?\}. Apart from this overhead, privatization also introduces the cost of
merging the parallel workers' states during checkpointing. In Figure
~\ref{fig:dijkstra_motivation} static analysis alone can disprove all RAW
dependences related to \texttt{\textbf{pathcost}} and safely privatize it.
However, because \texttt{\textbf{pathcost}} is a live-out object, each
write to it requires a log in order to determine which worker last wrote
each byte of the object. We can infer, though, that the \texttt{for} loop
in lines \textbf{28} and \textbf{29} will overwrite
\texttt{\textbf{pathcost}} at every iteration. Thus, the live-out values
will only come from the last iteration and no bookkeeping is needed.

\subsection{Motivation}
This work is motivated by opportunities to reduce or even remove two
major overheads, namely the excessive use of memory speculation and the
expensive privatization, of prior speculative systems that significantly
limits their efficiency.
%
In the next section, we will show that using speculation-aware memory
analyzer in conjuction with efficient privatization allows an efficient and
scalable automatic parallelization while maintaining the state-of-the-art
applicability.


\lstset{basicstyle=\ttfamily, numbers=left, numberstyle=\tiny,
  stepnumber=1, numbersep=5pt}
\begin{figure}[t]
  \centering
  %\begin{tabular}{cc}
  \scriptsize
%\resizebox{0.8\linewidth}{!}{
    \subfloat{
    \begin{minipage}{5cm}
      \input{figures/dijkstra_motivation}
    \end{minipage}
    }
\caption{Sequential \textit{dijkstra} example from MiBench~\cite{}}
\label{fig:dijkstra_motivation}
\end{figure}
