Enabling transformations address memory, register or/and control
cross-iteration dependences.

\subsubsection{Memory Dependences}

Memory-related enabling transformation collect a set of memory objects
for which they are applicable (see ~\ref{enablers}).

%TODO: maybe add discussion about their cost

\begin{itemize}
%
\item Privatization: Discussed in ~\ref{novel_transf}

\item Reduction: Applicable for objects that only participate in
reduction operations. When applied, reallocates
its objects to the reduction heap. At commit, objects of parallel
workers are merged according to their reduction operation.

%Applicability guard: objects that only participate to reduction
%operations

%Transformation Application: only separate objects to reduction heap

%Runtime support: at commit merge all objects according to their
%reduction operation

\item Short-lived: Applicable for objects that only exist within one
iteration of the loop. Reallocates its objects to the
short-lived heap when applied and inserts check to ensure that all
the objects of the heap are freed at the end of the iteration.
% During runtime, the short-lived property is checked.

\item Read-only: Applicable for objects that are never written to within
the loop. Reallocates its objects to the read heap when applied. Requires no
transformation-specific checks.

\item IO deferral: Applicable for shared IO objects. When applied, it
replaces IO library calls with custom calls. During runtime, it
collects output operations and performs them in order at commit.

\end{itemize}

\subsubsection{Register \& Control Dependences}

Cross-iteration register dependences
%(not related to induction variables)
are handled with reduction, replication, control speculation or value
prediction. Replication replicates side-effect free computation across
parallel workers to overcome cross-iteration dependences and avoid
inter-thread communication.
%
Cross-iteration control dependences are handled either with
replication or control speculation.
%mention IV?
Use of replication allows handling of uncounted loops, namely loops
with unknown trip count when the loop is invoked.
%
In terms of transformation cost, all transformations have constant
cost except for replication.  Replication's cost depends on how many
instructions need to be replicated. Non-speculative enablers
(reduction and replication) are preferred, in most cases, over
speculative ones, and reduction is preferred over replication.

%Cross-iteration register and control dependences related to induction
%variables are handled differently if detected.

%handling live-outs, loop-carried
%
%In the case of speculative executive, registers with cross-iteration
%dependences and live-out registers
%are stored in memory at commit so that they are recoverable in case of
%misspeculation. For live-outs, storing to memory

%\begin{itemize}
%
%\item Scalar Reduction
%
%\item Replication: Replicate side-effect free computation across
%parallel workers.
%
%\end{itemize}
%
%\subsubsection{Control Dependences}
%
%\item Induction Variable Detection: Every worker gets assigned a
%
%\item Replication: Replicate cross-iteration control dependences for
%each worker
%
%\item Control Speculation: Speculate cross-iteration control
%dependences
