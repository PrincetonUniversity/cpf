Enabling transformations address memory, register or/and control
cross-iteration dependences.

\subsubsection{Memory Dependences}

Memory-related enabling transformation collect a set of memory objects
for which they are applicable (see ~\ref{enablers}).

\begin{itemize}
%
\item Privatization: Discussed in ~\ref{novel_transf}

\item Reduction: Applicable for objects that only participate to
reduction operations. When applied, separates its objects to the
reduction heap and inserts separation checks (check that their
accesses are within this heap). During runtime, separation is checked
and at commit objects of parallel workers are
merged according to their reduction operation.

%Applicability guard: objects that only participate to reduction
%operations

%Transformation Application: only separate objects to reduction heap

%Runtime support: at commit merge all objects according to their
%reduction operation

\item Short-lived: Applicable for objects that only exist within one
iteration of the loop. When applied, separates its objects to the
short-lived heap and inserts check to ensure separation and that all
the objects of the heap are freed at the end of the iteration. During
runtime, the short-lived property and separation are checked.

\item Read-only: Applicable for objects that are never written to.
When applied, separates its objects to the read heap and inserts
separation checks.  During runtime, separation is checked.

\item TXIO: Applicable for shared IO objects. When applied, it
replaces IO library calls with custom calls. During runtime, it
collects output operations and performs them in order at commit.

\end{itemize}

\subsubsection{Register \& Control Dependences}

Cross-iteration register dependences
%(not related to induction variables)
are handled either with reduction or replication. Replication
replicates side-effect free computation across parallel workers to
overcome cross-iteration dependences and avoid inter-thread
communication.
%
Cross-iteration control dependences are handled either with
replication or control speculation.
%mention IV?
Use of replication allows handling of uncounted loops, namely loops
with unknown trip count when the loop is invoked.
%
In terms of transformation cost, reduction is preferred over
replication and replication is preferred over control speculation.

%Cross-iteration register and control dependences related to induction
%variables are handled differently if detected.

%handling live-outs, loop-carried
%
%In the case of speculative executive, registers with cross-iteration
%dependences and live-out registers
%are stored in memory at commit so that they are recoverable in case of
%misspeculation. For live-outs, storing to memory

%\begin{itemize}
%
%\item Scalar Reduction
%
%\item Replication: Replicate side-effect free computation across
%parallel workers.
%
%\end{itemize}
%
%\subsubsection{Control Dependences}
%
%\item Induction Variable Detection: Every worker gets assigned a
%
%\item Replication: Replicate cross-iteration control dependences for
%each worker
%
%\item Control Speculation: Speculate cross-iteration control
%dependences
