
\subsubsection{Memory Dependences}

% Memory-related enabling transforms collect a set of memory objects
% for which they are applicable (see ~\cref{enablers}).

\paragraph{Applicability:}
%
The applicability guard of a transform uses the results of the
speculation-aware memory analyzer to determine which memory objects
satisfy the properties required by the transform and records the
speculative assumptions used.
%
% XXX Make sure to add that assumptions need to be validated at runtime
% later on
% The applicability guard also records the speculative assumptions used
% to infer applicability for a memory object. These assumptions would
% need to be validated at runtime for the transform to be correct.

\paragraph{Transform proposal:} The output of each applicability
guard is assembled in a transform proposal which is sent to the
DOALL planner (\cref{planner}).
%
The proposal includes for each memory object an estimated handling
cost based on the transform itself and the validation cost of the
used speculative assumptions.
%
%The cost of each transform is determined by the cost of the
%transform itself and the cost of the speculative assumptions
%required for the transform to be applicable.
%
For simplicity, each transform and speculation
validation operation is assigned a fixed
%predefined
cost that ensures a basic ordering among the options. For
example,
%regarding speculative assumptions,
memory speculation has an extremely high cost (expensive validation),
loaded value prediction has a much smaller cost, while
control speculation has no cost.
%The estimated cost computation is very basic and just ensures basic
%ordering among the options.
%
%Every transform is assigned an arbitrary cost that ensures some
%ordering among transform. Speculative assumptions is similarly
%computed.
%
For the set of transforms and speculative assumptions in our
framework and in the context of DOALL parallelization, this simplified
cost model proved sufficient for detection of minimal cost plans.

%TODO: maybe add discussion about their cost
\paragraph{Transform Application:}
Each transform reallocates
memory objects it is selected to handle
%If, during the planning phase, a transform is selected for a set
%of memory objects, then during the code transform phase, the
%transform separates these objects
to its own heap, disjoint from any others; transforms may also
perform additional transform-specific modifications.

Separating objects is essential
for two reasons. First, each transform may demand different
memory mapping semantics and handles objects differently at commit.
Second, mapping of memory accesses to
objects often relies on profiling information, especially in languages with
unrestricted pointers like C/C++. Ensuring that all objects' accesses
are contained within a transform's heap is sufficient to
validate underlying object assumptions. This idea of separation has
been explored previously by Johnson et al. (Privateer~\cite{johnson:12:pldi}).

% Memory-related enabling transforms collect a set of memory objects
% for which they are applicable (see ~\cref{enablers}).
Memory-related enabling transforms include:

\begin{itemize}
%
  \item Privatization: Applicable for objects with no false dependences.
  Requires costly logging and merging at commit.

\item Reduction: Applicable for objects that only participate in
reduction operations. At commit, objects of parallel
workers are merged according to their reduction operation.

%Applicability guard: objects that only participate to reduction
%operations

%transform Application: only separate objects to reduction heap

%Runtime support: at commit merge all objects according to their
%reduction operation

\item Short-lived: Applicable for objects that only exist within one
iteration of the loop. Inserts check to ensure that all
the objects of the heap are freed at the end of each iteration.
% During runtime, the short-lived property is checked.

\item Read-only: Applicable for objects that are never written to within
the loop. Requires no transform-specific checks.

\item IO deferral: Applicable for shared IO objects. When applied, it
replaces IO library calls with custom calls. During runtime, it
collects output operations and performs them in-order at commit.

\end{itemize}

\paragraph{Efficient privatization variants}
\label{novel_transf}
We propose four efficient variants of the privatization transform.
% To avoid expensive monitoring of write sets during parallel execution
% and minimize copy-out costs, we propose four efficient variants of
% this transform, introduced in \cref{new_enablers}.
\begin{itemize}
%
\item Independent: This transform's heap is shared
  among all parallel workers, since there is no overlapping memory
  accesses.
  %
  No monitoring of write sets is needed. At commit, the heap is copied-out
  to the non-speculative state.
%
%If the selected parallelization plan is non-speculative, then this
%heap is also shared with the main process and copy-in and copy-out
%overheads are eliminated as well.

%Behavior : No write set monitoring performed. Memory object is shared among parallel workers.

\item Overwrite Private: This transform's heap has
  CoW (copy-on-write) mapping. At the end of the parallel
  invocation, the last executed iteration
  state is copied-out and no monitoring is needed.

%Additional applicability guard:
%object has loop-invariant condition for last update within the loop.
%
%Behavior: No write set monitoring performed. The live-out state for
%object with this property is the memory state of the last iteration
%executed before commit.

\item Predictable Private: This transform's heap
  has CoW mapping. The live-out state is predictable, so no monitoring
  or merging of parallel workers state is needed. This transform
  relies on value prediction's speculative assumptions.

\item Local Private: This transform's heap has
  CoW mapping, and there is no need for copy-out or monitoring.

\end{itemize}

% The applicability guard also records the speculative assumptions used
% to infer applicability for a memory object. These assumptions would
% need to be validated at runtime for the transform to be correct.
%Separation checks are required for memory accesses whose underlying
%objects are discovered via profiling.
%The runtime function for re-allocation of memory objects can be
%specialized by each transform.
%
%Each transform has its own runtime support for handling its
%objects during execution.

%The idea of separating memory objects has been explored previously by
%Johnson et al. (Privateer~\cite{johnson:12:pldi}).  However, Privateer
%employs a monolithic design that entangles classification of memory
%objects with memory speculation and other
%%monolithic design of memory object classification entangles
%%separation speculation with memory speculation and other
%profiling-based information, resulting in unnecessarily high runtime
%overheads (see example in section~\ref{motiv_example} and performance
%analysis in section ~\ref{eval}).
%%
%By contrast, \name employs a modular and extensible design that
%facilitates planning and selection of minimal cost solutions without
%unnecessary speculation.
%where enabling transforms offer to handle memory objects along
%with estimated costs -offers with costs and the selection happens.
%

%Every transform can optimize the checks that are applied to its
%objects knowing that there is no aliasing with other objects handled
%by different transforms.

%ensures that all accesses of a memory object have the required
%properties.

% We describe in the next section efficient variants of the speculative
% privatization transform, which constitute a contribution of this
% paper.  Other enabling transforms that are used in our framework
% but have been proposed in prior work are discussed in
% section \ref{design_transf}.
% We propose the following enabling transforms for addressing memory,
% register, and/or control cross-iteration dependences.

\subsubsection{Register \& Control Dependences}

Cross-iteration register dependences
%(not related to induction variables)
are handled with reduction, replication, control speculation or value
prediction. Replication replicates side-effect-free computation across
parallel workers to overcome cross-iteration dependences and avoids
inter-thread communication.
%
Cross-iteration control dependences are handled either with
replication or control speculation.
%mention IV?
Use of replication allows handling of uncounted loops, namely loops
with unknown trip count when the loop is invoked.
%
In terms of transform cost, all transforms have constant
cost except for replication.  Replication's cost depends on how many
instructions need to be replicated. Non-speculative enablers
(reduction and replication) are preferred, in most cases, over
speculative ones, and reduction is preferred over replication.

%Cross-iteration register and control dependences related to induction
%variables are handled differently if detected.

%handling live-outs, loop-carried
%
%In the case of speculative executive, registers with cross-iteration
%dependences and live-out registers
%are stored in memory at commit so that they are recoverable in case of
%misspeculation. For live-outs, storing to memory

%\begin{itemize}
%
%\item Scalar Reduction
%
%\item Replication: Replicate side-effect free computation across
%parallel workers.
%
%\end{itemize}
%
%\subsubsection{Control Dependences}
%
%\item Induction Variable Detection: Every worker gets assigned a
%
%\item Replication: Replicate cross-iteration control dependences for
%each worker
%
%\item Control Speculation: Speculate cross-iteration control
%dependences
