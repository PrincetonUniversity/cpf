\section{The \name Approach}
\label{sec:approach}

Current parallelizing compiler designs involve code analyses, transforms,
and speculative techniques to work mostly independently.
This design makes important parallelization opportunities unreachable.
To overcome this limitation, \name introduces a compiler design where static code analyses and speculation techniques are tightly coupled to boost their discovery of parallelization opportunities.
This tight interaction generates information in the form of a dependence graph annotated with speculative assertions.
\namensp's design also tightly couples code transforms with speculative assertions to drastically reduce the overhead of the formers.
These new interfaces create extra degrees of freedom, which enable \name to realize many new parallelization opportunities reaching the applicability of speculation-based approaches with the efficiency of static analyses ones.

%\name combines a speculation-aware memory analyzer, enabling
%transforms including efficient speculative privatization, and a
%parallelization planner into an exploration phase designed to find the
%best performing set of parallelization techniques.  This section
%discusses the main contributions of this paper
%(sections~\ref{analyzer},\ref{enablers},\ref{planner}), and
%presents a code example (section~\ref{motiv_example}) to underline
%improvements over Privateer~\cite{johnson:12:pldi}, a state-of-the-art
%speculative DOALL parallelization system.

\subsection{Planning}
\label{planning}
%
Unlike prior speculative systems that apply a sequence of
parallelization-enabling transforms in a fixed order, \name proposes a
more sensible approach: before applying any transform, plan
first.

Enabling transforms modify the code to remove parallelization
inhibitors, which in the context of DOALL parallelization are
cross-iteration dependences.
%
To facilitate planning, all transforms are split into two parts.
The applicability guard that participates in the planning phase of the
compilation, and the actual transform that is applied, if
selected, in the transform phase.
%This separation of decision making and application of transforms
%allows \name to carefully select the most profitable plan.
The applicability guard utilizes properties produced by memory
analysis and speculative assertions\footnote{We define speculative
assertions as predictions of program properties based on profile
information.} to determine which parallelization inhibitors the
corresponding transform can handle.
%
The interface between memory analysis and speculative assertions, and
enabling transforms is an annotated with properties program dependence
graph (PDG).
%
%The used speculative assertions would need to be validated at
%runtime for the transform to be correct.
%
The output of each applicability guard is collected in a
transform proposal which is sent to the planner.
%
%The effect of each enabling transform is collected in a
%transform proposal.
%
The proposal also includes a cost for the application of the
transform itself and a set of speculative assertions required
for the transform to be applicable and correct.

Memory-related transforms, instead of targeting cross-iteration
dependences, offer to handle a set of memory objects, in effect
addressing all their cross-iteration dependences. This object-centric
approach is motivated by the fact that memory-related enabling
transforms often operate at an object level. For example, the
privatization transform creates private copies of memory objects.

\paragraph{Planner}

%The input to the planner is a program dependence graph and
%transform proposals of the enabling transforms.
%
The output of the planner is the best performing set of
transforms that addresses all the parallelization inhibitors.
%
The planner is able to perform global reasoning by centralizing the
currently decentralized and greedy decision-making process found in
prior parallelizing compilers.
%
The generated plan includes a set of enabling transforms and a
set of transforms for validating speculative assertions.
%
These are the transforms that are applied at the transform
phase of compilation.

\subsection{Speculation-Aware Memory Analyzer}
\label{sama_short}

Prior techniques use memory analysis and speculative assertions
independently.  Instead, this work proposes a speculation-aware memory
analyzer that combines the strengths of static analysis and
cheap-to-validate speculative assertions to reduce the need for
expensive speculation.  If memory analysis fails on its own to resolve
an analysis query, it interprets cheap-to-validate speculative
assertions as facts ignoring the possibility of misspeculation.
%
The inclusion of speculation changes the semantics of traditional
memory analysis. It is now required to specify for each answer the
speculative assertions, if any, that were used in the process.
%
Just applying speculation and then querying memory analysis again
would not have the same effect since the possibility of misspeculation
restrains static analysis. For more details regarding
speculation-aware memory analysis see \cref{sama}.

\subsection{New Enabling Transforms}
\label{new_enablers}

%Either all static, all speculation.
Prior work on speculative parallelization often focuses on the
enabling effect of transforms without considering their cost.  To
maximize applicability, enabling transforms are often given a program
dependence structure relaxed with the use of all the available
speculative assertions.  This approach not only creates ambiguity in
terms of what speculative assertions are necessary but also prevents
usage of efficient variants of transforms.
%
By exposing a combination of static analysis information and
speculative assertions, \name enables more efficient enabling
transforms.  This is especially true for the case of speculative
privatization, efficient variants of which are explored in this paper.
%
We first discuss speculative privatization as it appears in prior work
and then describe new variants that perform more efficient
privatization.

Prior software speculative systems with extended support of
privatization~\cite{johnson:12:pldi,kim:12:cgo} only infer the basic
privatization property that there are no cross-iteration data flows
for a memory object.
%
Speculative privatization application involves costly instrumentation
of all write accesses of privatized objects for logging or
communication. At commit, the private copies of each worker are merged
according to metadata that specify which worker last wrote each byte.

To avoid expensive monitoring of write sets during parallel execution
and minimize copy-out costs, we propose four efficient variants of
this transform.
%
These variants require additional memory object properties apart from the basic
privatization property to be applicable.  Private
objects could additionally be (a) be independent (no loop-carried false
dependences); (b) overwrite (written at the same locations at every
loop iteration); (c) predictable (predictable live-out content);
or (d) local (allocated outside the loop, but all accesses are
contained within the loop).

Inference of any of these four private properties allows complete
elimination of bookkeeping costs, required by basic privatization.
The first two variants have been explored by Tu et
al.~\cite{tu:94:lcpc} but were limited to static analysis based
detection of privatization. Unlike any prior work, \name extends
the applicability of these two variants with the usage of speculative
assertions to programs with pointers, dynamic allocation, and type
casts.





\lstset{basicstyle=\ttfamily, numbers=left, numberstyle=\tiny,
  stepnumber=1, numbersep=5pt}

\begin{figure*}[!t]
\centering
\resizebox{0.86\linewidth}{!}{
\subfloat[Privateer~\cite{johnson:12:pldi}]{
  \centering
  \includegraphics[width=0.46\textwidth]{figures/privateer-example-crop}
}
\qquad
\subfloat[\name (This Work)]{
  \centering
  \includegraphics[width=0.46\textwidth]{figures/perspective-example-crop}
}
}
\caption{Comparison of decision process for handling memory
objects \texttt{\textbf{pathcost}} and \texttt{\textbf{dist}} of
\texttt{dijkstra}. Numbers in circles are line numbers in
Figure~\ref{fig:dijkstra_motivation}; ``UO=\{\#\}'' means the underlying
object is allocated/declared in line \#.}
\label{fig:dijkstra_motivation_comparison}
\end{figure*}

\begin{figure*}[!h]
\centering
\scriptsize
\resizebox{0.86\linewidth}{!}{
  % \subfloat[Sequential code]{
  %   \begin{minipage}{6cm}
  %     \input{figures/dijkstra_motivation}
  %   \end{minipage}
  %   }
\subfloat[Privateer~\cite{johnson:12:pldi}]{
  \centering
  \begin{minipage}{9.4cm}
  \input{figures/dijkstra_motivation_checks}
  \end{minipage}
}
\qquad
\qquad
\subfloat[\name (This Work)]{
  \centering
  \begin{minipage}{8.2cm}
  \input{figures/dijkstra_motivation_checks_our}
  \end{minipage}
}
}
\caption{Comparison of parallelized code of \texttt{dijkstra}. Logging and
checks during loop execution dominate the overheads, indicated in the code
as ``added OH''.}
\label{fig:dijkstra_motivation_comparison_source_code}
\end{figure*}
%caption,
%Checkpointing occurs every several (long running) loop iterations, thus its
%overhead is negligeable for \textit{dijkstra}.


\subsection{Example}
\label{motiv_example}

Next, we describe how \name succeeds at parallelizing \texttt{dijkstra}
efficiently. This section also highlights the limitations of prior
work and how the new ideas introduced in \name
(\cref{planning}, \cref{sama_short}, \cref{new_enablers}) overcome them.
%
Consider again the code in Figure~\ref{fig:dijkstra_motivation},
briefly discussed in~\cref{motiv_overheads}.
%
Figure~\ref{fig:dijkstra_motivation_comparison} compares the
compilation flow of \name with that of Privateer for handling memory objects
\texttt{\textbf{pathcost}} and \texttt{\textbf{dist}}.

\name employs an exploration phase that yields a much more profitable plan
than Privateer's scheme.
%The PDG is annotated by the speculation-aware memory
Notice how the PDG is annotated with properties and underlying speculative
assertions by the \textbf{speculation-aware memory analyzer} which allows
removal of the RAW dependence between instruction \textbf{13} and
\textbf{38} with a combination of static analysis and control speculation.
This dependence would require usage of memory speculation in prior work.
%
% Just removing dependences in the PDG creates ambiguity on how a
% dependence can be resolved, leading to over-speculation. The PDG
% contains useful properties even for non-removable dependences. For
% example,

Non-removable WAW edges in this example are annotated with
the \textit{overwrite} property that indicates that the destination
operation always overwrites the footprint of the source operation.
%
Based on the information on the PDG, three different transforms offer
handling of memory objects, including \textbf{overwrite privatization} and
\textbf{local privatization} proposed in~\cref{new_enablers}.

%For example, handling of \textit{dist} requires usage of control
%speculation (for the branch in line 11,
%fig.~\ref{fig:dijkstra_motivation}).
%
%Notice that \textit{dist} can be handled by all three
%transforms.
%
The \textbf{DOALL planner} then selects the lowest cost solution for each memory
object. For example, the local privatization's
offer is selected for \texttt{\textbf{dist}} since it is the cheapest
privatization transform, and its
speculative assertion is the same as those of other options.
The \texttt{\textbf{nDist}} object (not shown in this figure) is also handled
by local privatization. \texttt{\textbf{pathcost}} is resolved by overwrite
privatization.
% %
% Extracting this efficient plan would not be possible without the use
% speculation-aware memory analyzer and efficient speculative
% privatization transforms.

% From prior work, Privateer~\cite{johnson:12:pldi} is the only
% automatic system to support privatization of dynamically allocated
% objects, like \textit{pathcost}, even in the presence of unrestricted
% pointers.


%
Privateer, on the other hand, relies on profile information to infer
that these two objects are privatizable and is forced to apply
transforms with privacy checks and merging of private copies,
resulting in high runtime overheads. The use of a speculatively
relaxed PDG necessitates memory speculation validation, as it is
ambiguous how each dependence was removed.  Moreover, a speculative
PDG with no further information prevents the application of the
efficient speculative privatizations variants described in this paper.

%Even if memory analysis was used instead of memory speculation, the
%classifier sees the optimistic view of the program
%


%not only in Privateer but in any other automatic parallelization
%speculative system.


%Whilst the private property is enough for DOALL
%Notice that we infer an additional property that improves the profitability
%of parallelization.

%For inferring the property that a private memory object has the additional local-private
%property, it suffices to identify all accesses of the memory object
%and check that all of them are within the loop.
%locally-accessed property.


Figure~\ref{fig:dijkstra_motivation_comparison_source_code} compares the
resulting parallelized versions (in a simplified form) of \name and
Privateer. The code includes all the added checks, logging, and live-out
handling overheads. The code changes are marked with the average added
overhead compared to the useful work of each worker. It is clear that \name is
able to parallelize \texttt{dijkstra} with minimum overheads thanks to the
use of speculative-aware memory analyzer, careful selection of applied
transforms, and use of efficient privatization variants. In fact,
\name exhibits 4.8$\times$ speedup over Privateer for \texttt{dijkstra}
(see~\cref{eval}).

%Privateer would choose to just do simple privatization with mem spec.
%The spec-aware analyzer allows removal of mem spec and efficient
%privatization in this case.
%
%\begin{itemize}
%\item
%Privatization of these memory objects requires:
%\begin{enumerate}
%\item
%identification of all accesses of these objects
%    within the loop
%\item
%absence of cross-iteration flow
%     dependences on each of these accesses
%\end{enumerate}
%
%\end{itemize}
%
%
%DOALL can become applicable if these two objects are proven to have the
%private property.
%
%We compare our approach where we combine static analysis with cheap-to-validate
%with privateer's monolithic approach that over-speculates and is limited by high
%runtime overheads.
%
%Note that anti-dependences are ignored since both systems use
%process-based runtime systems.
