#!/bin/bash

if [[ x$CG != x ]]
then
  echo CodeGen enabled
else
  echo CodeGen disabled
fi

ECPROF=
if [ -a ./llvmprof.out ]
then
  ECPROF="-pgo-instr-use -pgo-test-profile-file=./llvmprof.out"
  echo Edge profile information available...
fi

SPPROF=
if [ -a ./result.specpriv.profile.txt ]
then
  SPPROF="-read-specpriv-profile"
  echo SpecPriv profile information available...
fi

LPROF=
if [ -a ./result.lamp.profile ]
then
  echo Lamp profile available
  LPROF=" -lamp-inst-cnt -lamp-map-loop -lamp-load-profile "
fi

# Determine if the user specified a function
FCN=
if [[ x$2 != x ]]
then
  FCN="-target-fcn=$2"
fi

# Determine if the user specified a loop
LOOP=
if [[ x$3 != x ]]
then
  LOOP="-target-loop=$3"
fi

# Determine if the user provided a modifier.
# Valid choices are:
# - memcheck
# - massif
# - gdb
PREFIX=time
if [[ x$GDB != x ]]
then
  PREFIX="gdb --args "
elif [[ x$MASSIF != x ]]
then
  PREFIX="valgrind --tool=massif --heap=yes --massif-out-file=massif.out "
elif [[ x$MEMCHECK != x ]]
then
  PREFIX="valgrind --tool=memcheck --leak-check=full --malloc-fill=aa --free-fill=dd "
fi

if [[ x$TIMER == x ]]
then
  SPEX="$LIBERTY_LIBS_DIR/libspecprivexecutive.so"
else
  SPEX="$LIBERTY_LIBS_DIR/libspecprivexecutive_timer.so"
fi

if [[ x$V2 != x ]]
then
  mode=_v2
elif [[ x$V1 != x ]]
then
  mode=_v1
elif [[ x$PRIV != x ]]
then
  mode=_privateer
else
  mode=
fi

LIBS="-load $LIBERTY_LIBS_DIR/libUtil.so
      -load $LIBERTY_LIBS_DIR/libExclusions.so
      -load $LIBERTY_LIBS_DIR/libAnalysis.so
      -load $LIBERTY_LIBS_DIR/libLoopProf.so
      -load $LIBERTY_LIBS_DIR/libMetadata.so
      -load $LIBERTY_LIBS_DIR/libLAMPLoad.so
      -load $LIBERTY_LIBS_DIR/libLAMP.so
      -load $LIBERTY_LIBS_DIR/libSLAMP.so
      -load $LIBERTY_LIBS_DIR/libRedux.so
      -load $LIBERTY_LIBS_DIR/libPointsToProfiler.so
      -load $LIBERTY_LIBS_DIR/libGraphAlgorithms.so
      -load $LIBERTY_LIBS_DIR/AllocAA.so
      -load $LIBERTY_LIBS_DIR/TalkDown.so
      -load $LIBERTY_LIBS_DIR/PDGAnalysis.so
      -load $LIBERTY_LIBS_DIR/libPDGBuilder.so 
      -load $LIBERTY_LIBS_DIR/libGraphAlgorithms.so 
      -load $LIBERTY_LIBS_DIR/HotProfiler.so
      -load $LIBERTY_LIBS_DIR/Parallelization.so
      -load $LIBERTY_LIBS_DIR/libStrategy.so
      -load $LIBERTY_LIBS_DIR/libOrchestration${mode}.so
      -load $LIBERTY_LIBS_DIR/libSpeculation${mode}.so
      -load $LIBERTY_LIBS_DIR/Heuristics.so 
      -load $LIBERTY_LIBS_DIR/ParallelizationTechnique.so
      -load $LIBERTY_LIBS_DIR/DOALL.so
      -load $LIBERTY_LIBS_DIR/libCodeGen${mode}.so"


AA=`aa`
EXTRA="-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa -objc-arc-aa -scoped-noalias -llvm-aa-results"

if [[ x$CG != x ]] || [[ x$PP != x ]]
then
OPTS="$LPROF $SLPROF $AA $EXTRA $SPPROF $HDRPHIPROF
  -remed-selector
  -spec-priv-preprocess
  -spec-priv-apply-separation-spec
  -spec-priv-apply-control-spec
  -spec-priv-apply-value-pred-spec
  -specpriv-mtcg
  -stats 
  $DBG "

else
OPTS="$LPROF $SLPROF $AA $EXTRA $SPPROF $HDRPHIPROF
  -remed-selector
  -stats 
  $DBG "
fi

OUTFILE_EXE=`basename $1 .bc`.collaborative${mode}.exe
NOPEEP=`basename $1 .bc`.collaborative${mode}-pipeline-nopeep.bc
OUTFILE=`basename $1 .bc`.collaborative${mode}-pipeline.bc
ASMOUT=`basename $1 .bc`.collaborative${mode}-pipeline.s
OUTFILE_BC_LINKED=`basename $1 .bc`.collaborative${mode}.linked.bc
OUTFILE_BC_OPT=`basename $1 .bc`.collaborative${mode}.opt.bc
OUTFILE_BC_OPT_STRIP=`basename $1 .bc`.collaborative${mode}.opt.striped.bc
OUTFILE_OBJ=`basename $1 .bc`.collaborative${mode}.o

if [[ x$CG != x ]]
then
  DUMPFILE=`basename $1 .bc`.collaborative${mode}-parallelized.dump
else
  DUMPFILE=`basename $1 .bc`.collaborative-pipeline.dump
fi

OUTFILE_STATIC_EXE=`basename $1 .bc`.collaborative${mode}_static.exe

rm -f $NOPEEP
OUT="-o $NOPEEP"

CMD="$PREFIX opt $1 $LIBS $OPTS $FCN $LOOP $OUT"

echo Running: $CMD
ulimit -S -v $[12*1024*1024]
## use .bc file to generate executable
$CMD > $DUMPFILE 2>&1

if [[ x$CG != x ]]
then
# procude executable
#####
RUNTIME_CFLAGS="-DDEBUG"
OPT_LEVEL="-O3"
CPP=clang++


#### The peephole optimizer (aka the 'postprocessor')

BEGIN="$PREFIX2 opt $LIBS $AA -spec-priv-postprocess-1 -dce -stats $DBG $EXTRA1 "
MIDDLE="$PREFIX2 opt $LIBS $AA -loop-simplify -indvars -spec-priv-postprocess-2 -stats $DBG $EXTRA2"
END="$PREFIX2 opt $LIBS $AA -spec-priv-postprocess-3 -stats $DBG $EXTRA3 "

echo Postprocessor step 1
$BEGIN $NOPEEP -o tmp1${mode}.bc 2>&1 || exit
echo
echo Postprocessor step 2a
$MIDDLE tmp1${mode}.bc -o tmp2${mode}.bc 2>&1 || exit
opt -O3 tmp2${mode}.bc -o tmp2${mode}.o3.bc 2>&1 || exit
echo
echo Postprocessor step 2b
$MIDDLE tmp2${mode}.o3.bc -o tmp3${mode}.bc 2>&1 || exit
opt -O3 tmp3${mode}.bc -o tmp3${mode}.o3.bc 2>&1 || exit
echo
echo Postprocessor step 2c
$MIDDLE tmp3${mode}.o3.bc -o tmp4${mode}.bc 2>&1 || exit
opt -O3 tmp4${mode}.bc -o tmp4${mode}.o3.bc 2>&1 || exit
echo
echo Postprocessor step 3
$END tmp4${mode}.o3.bc -o tmp5${mode}.bc 2>&1 || exit
opt -O3 tmp5${mode}.bc -o $OUTFILE 2>&1 || exit
echo

#### Link and Code Gen
echo Produce executable
$CPP $OPT_LEVEL -c -emit-llvm -o $OUTFILE_BC_OPT $OUTFILE
opt -strip -o $OUTFILE_BC_OPT_STRIP $OUTFILE_BC_OPT

$CPP -std=c++14 -pthreads $OPT_LEVEL $OUTFILE_BC_OPT_STRIP -lm $SPEX -lrt -o $OUTFILE_EXE
fi

#### Cleanup
rm -f tmp1${mode}.bc tmp2${mode}.bc tmp2${mode}.o3.bc tmp3${mode}.bc tmp3${mode}.o3.bc tmp4${mode}.bc tmp4${mode}.o3.bc tmp5${mode}.bc *.cvc3
