//===- LAMPProfiling.cpp - Insert LAMP instrumentation -----------===//
//
// These sets of passes instruments the specified program with calls for
// loop-aware memory profiling.  It provides three classes for the complete
// LAMP instrumentation.  The first (LdStCallCounter counts loads and stores,
// the second (LAMPLoopProfiler) instruments and counts loops, and the
// third (LAMPProfiler) completes the instrumentation with initilization and
// instrumentation of individual loads and stores.
//
// 07/07/08 -- created LdStCallCounter, created LAMPProfiler -- TRM
// 07/11/08 -- added call instrumentation to LAMPProfiler -- TRM
// 07/14/08 -- added LAMPLoopProfiler to instrument and count loops, added
//    functionality for init with numLoops -- TRM
// 07/17/08 -- Converted LAMPProfiler to function pass because doInitialization
//    cannot use other analyses.
// 07/18/08 -- Created Special pass for initialization, made static variables,
//    various structural changes to fit what llvm allows.
// 07/24/08 -- Added allocate/free instrumentation
// 07/25/08 -- Tested, profiling correctly  Horray.
// 07/29/08 -- Truncated allocate mem addr and size values to 8 and 32 respectively
//    ... not sure if this is appropriate.
//
// These passes must be called in this order:
//  LdStCallCounter->LAMPProfiler->LAMPLoopProfiler->LAMPInit
//
// LAMPLoopProfiler and LdStCallCounter are required for initialization counts.
// LAMPProfiler must be permitted to profile loads, stores, calls before the
//   LAMPLoopProfiler adds loop profiling calls or it may profile instrumentation
//   calls.
// (LdStCallCounter could actually be called after LAMPProfiler safely).
//
//
//===----------------------------------------------------------------------===//
#define DEBUG_TYPE "LAMP"

#define defTLAMP 0

// designed tmason, pprabhu
// edited tmason
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/DebugInfo.h"
#include "llvm/IR/CallSite.h"

#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Module.h"
#include "llvm/Pass.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/Target/TargetInstrInfo.h"
#include "llvm/IR/DataLayout.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/Debug.h"
#include "LAMP/LAMPInstrumentation.h"

#include "llvm/Support/CommandLine.h" // For cl

#include "llvm/Analysis/LoopPass.h"  //TRM 7/21/08
#include "llvm/ADT/SmallVector.h"
#include "llvm/Analysis/Passes.h"  //TRM 7/21/08

#include "liberty/Utilities/GlobalCtors.h"
#include "liberty/LAMP/LAMPFlags.h"

#if defTLAMP
#include "LimitingInst.h"
#endif

//#include "LAMP/RSProfiling.h"
//#include "LAMP/ProfilingUtils.h"
#include <iostream>
#include <fstream>
#include <set>
#include <sstream>

using namespace llvm;
using namespace std;

using namespace liberty;

cl::opt<bool> PLAMP(
    "plamp", cl::init(false), cl::NotHidden,
    cl::desc("Use PLAMP profling"));

cl::opt<bool> TLAMP(
    "tlamp", cl::init(false), cl::NotHidden,
    cl::desc("Use targeted LAMP profling -- requires LimitingInst"));

cl::opt<int> SLAMP_RATE(
    "slamp-rate", cl::init(-1), cl::NotHidden,
    cl::desc("Sets sampling rate for sampling lamp"));

// This class is a module pass designed to do no modification or instrumentation but count the number of
// loads, stores, and calls for the initialization call.  It also tracks the loop counts generated by the
// loop profiler so they can be accessed by the initializing pass.
namespace {
  class LdStCallCounter : public ModulePass {
    public:
      static char ID;
      static bool flag;
      bool runOnModule(Module &M);
      static unsigned int num_loads;
      static unsigned int num_stores;
      static unsigned int num_intrinsics;
      static unsigned int num_calls;
      static unsigned int num_loops;
      LdStCallCounter(): ModulePass(ID)
    {

    }
      unsigned int getCountInsts()
      {
        return num_loads + num_stores + num_calls + num_intrinsics;
      }

      virtual void getAnalysisUsage(AnalysisUsage &AU) const {
        AU.setPreservesAll();
      }


  };

}

char LdStCallCounter::ID = 0;

// flag to ensure we only count once
bool LdStCallCounter::flag = false;

// only want these counted once and only the first time (not after other instrumentation)
unsigned int LdStCallCounter::num_loads = 0;
unsigned int LdStCallCounter::num_stores = 0;
unsigned int LdStCallCounter::num_intrinsics = 0;
unsigned int LdStCallCounter::num_calls = 0;
// store loops here also because loop passes cannot be required by other passes
unsigned int LdStCallCounter::num_loops = 0;

static RegisterPass<LdStCallCounter> RP1( "lamp-insts",
    "Count the number of LAMP Profilable insts for LAMPProfiling",
    false, false);

ModulePass *llvm::createLdStCallCounter() {
  return new LdStCallCounter();
}

  bool LdStCallCounter::runOnModule(Module &M) {
    if (flag == true)  // if we have counted already -- structure of llvm means this could be called many times
      return false;
    // for all functions in module
    for (Module::iterator I = M.begin(), E = M.end(); I != E; ++I)
      if (!I->isDeclaration())
      {      // for all blocks in the function
        for (Function::iterator BBB = I->begin(), BBE = I->end(); BBB != BBE; ++BBB)
        {    // for all instructions in a block
          for (BasicBlock::iterator IB = BBB->begin(), IE = BBB->end(); IB != IE; IB++)
          {
            if (isa<LoadInst>(IB))    // count loads, stores, calls
            {
              num_loads++;
            }
            else if (isa<StoreInst>(IB))
            {
              num_stores++;    // count only external calls, ignore declarations, etc
            }
            else if( isa<MemIntrinsic>(IB) )
            {
              num_intrinsics++;
            }
            //            else if (isa<CallInst>(IB) && ( (dyn_cast<CallInst>(IB)->getCalledFunction() == NULL) ||
            //                  (dyn_cast<CallInst>(IB)->getCalledFunction()->isDeclaration())))
            else if ( EX_CALL(IB))
            {
              num_calls++;
            }
          }
        }
      }
    LLVM_DEBUG(errs() << "Loads/Store/Intrinsics/Calls:" << num_loads << " " << num_stores
        << " " << num_intrinsics << " " << num_calls << '\n');
    flag = true;

    return false;
  }

/**********************************************************************
 **                   LAMPProfiler Pass                              **
 **********************************************************************/

typedef std::set<int> IntSet;

// LAMPProfiler instruments loads, stores, and calls.  Target data required to determine
// data size to be profiled.
namespace {
  class LAMPProfiler : public FunctionPass {
    bool runOnFunction(Function& F);

    bool isGlobalCtor(Function *f);
    void constructGlobalCtors(Module *m, Function *f);
    void constructCtors(Function *f);



    map<Function *, bool> *GlobalCtorMap;


    Constant* lampFuncs[9];
    Constant* CallFn;
    Constant* AllocFn;
    Constant* DeallocFn;
    void createLampDeclarations(Module* M);
    int getIndex(Type* ty);
    const DataLayout* TD;

#if defTLAMP
    LimitingInstModule *lim;
#endif

    public:
    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
#if defTLAMP
      AU.addRequired< LimitingInstModule >();
#endif
      AU.addPreserved< LdStCallCounter >();
    }

    StringRef getPassName() const { return "LAMPProfiler"; }

    bool doInitialization(Module &M) { return false; }
    static unsigned int instruction_id;
    static char ID;

    std::ofstream idout;

    LAMPProfiler() : FunctionPass(ID)
    {
      LLVM_DEBUG(errs() << "In LAMPProfiler ctor\n");

      lampFuncs[0] = NULL;
      TD = NULL;
#if defTLAMP
      lim = NULL;
#endif
      GlobalCtorMap = NULL;
      LLVM_DEBUG(errs() << "\n\n");
    }
  };
}


char LAMPProfiler::ID = 0;
unsigned int LAMPProfiler::instruction_id = -1;

static RegisterPass<LAMPProfiler> RP("insert-lamp-profiling",
    "Insert instrumentation for LAMP profiling", false, false);

static cl::opt<std::string> PRINTID("print-ldst-id", cl::init("disable"), cl::NotHidden, cl::desc("To enable printing ld/st ID to compare result with CLAMP"));

FunctionPass *llvm::createLAMPProfilerPass() { return new LAMPProfiler(); }

void LAMPProfiler::constructCtors(Function *f)
{
  if( !f )
    return;

  GlobalCtorMap->insert(pair<Function*,bool>(f,true));
  for(Function::iterator it = f->begin(); it!= f->end(); ++it)
  {
    BasicBlock *bb = &*it;
    for(BasicBlock::iterator bit = bb->begin(); bit!= bb->end(); ++bit)
    {
      Instruction *inst = &*bit;
      if(CallInst *call = dyn_cast<CallInst>(inst))
      {
        constructCtors(call->getCalledFunction());
      }
    }
  }

}

// TODO: this is the wrong way to solve the problem;
// instead, we should force lamp initialization to run before
// the global ctors.
void LAMPProfiler::constructGlobalCtors(Module *m, Function *f)
{
  GlobalCtorMap = new map<Function *, bool>();
  // If there was already a constructor list...
  GlobalVariable *previous = m->getGlobalVariable("llvm.global_ctors");
  if( previous )
  {
    // and it has an initializer
    if( previous->hasInitializer() )
    {
      // and if that initializer was an array
      if( ConstantArray *ca = dyn_cast<ConstantArray>( previous->getInitializer() ) )
      {
        for(User::op_iterator i=ca->op_begin(), e=ca->op_end(); i!=e; ++i)
        {

          Constant *constant = dyn_cast<Constant>(i->get());
          Function *func = dyn_cast<Function>(constant->getOperand(1));
          constructCtors(func);
        }
      }
    }
  }
}

bool LAMPProfiler::isGlobalCtor(Function *f)
{
  if(GlobalCtorMap->find(f) != GlobalCtorMap->end())
    return true;
  return false;
}
/**
 * Create the LAMP Declarations, should only be run one time
 */
void LAMPProfiler::createLampDeclarations(Module* M)
{
  std::string f[] = {"LAMP_load1", "LAMP_load2", "LAMP_load4", "LAMP_load8",
    "LAMP_store1", "LAMP_store2",  "LAMP_store4", "LAMP_store8"};

  std::string FnName = "LAMP_register";
  std::string AllocName = "LAMP_allocate";
  std::string DeallocName = "LAMP_deallocate";

  LLVMContext &ctx = M->getContext();
  Type *i8 = Type::getInt8Ty(ctx),
        *i32 = Type::getInt32Ty(ctx),
        *i64 = Type::getInt64Ty(ctx),
        *vty = Type::getVoidTy(ctx),
        *pi8 = PointerType::getUnqual(i8);

  for (int i=0; i < 4; i++)
  {
    //sot
    // signature of LAMP_load1 is void LAMP_load1(const uint32_t instr, const uint64_t addr)
    // there seems no need for the last arg
    //lampFuncs[i] = M->getOrInsertFunction(f[i], vty, i32, i64, (Type*)0);
    //lampFuncs[i+4] = M->getOrInsertFunction(f[i+4], vty, i32, i64, i64, (Type*)0);
    lampFuncs[i] = M->getOrInsertFunction(f[i], vty, i32, i64);
    lampFuncs[i+4] = M->getOrInsertFunction(f[i+4], vty, i32, i64, i64);
  }

  //CallFn = M->getOrInsertFunction(FnName, vty, i32, (Type*)0);
  CallFn = M->getOrInsertFunction(FnName, vty, i32);

  // args are unsigned32, void*, size_t ... seems to translate as these  TRM 7/25/08
  // should be 32, 8?, 32 -- currently defined as 32 64 64

  //sot
  //AllocFn = M->getOrInsertFunction(AllocName, vty, i32, pi8, i32, (Type*)0);
  AllocFn = M->getOrInsertFunction(AllocName, vty, i32, i8, i32);

  //DeallocFn = M->getOrInsertFunction(DeallocName, vty, i32, i8, i32, (Type*)0);

  //sot
  //DeallocFn = M->getOrInsertFunction(DeallocName, vty, i32, pi8, (Type*)0);
  DeallocFn = M->getOrInsertFunction(DeallocName, vty, i32, i8);

  //sot
  /*
  M->getOrInsertFunction("LAMP_llvm_memcpy_p0i8_p0i8_i32", vty, i32, pi8, pi8, i32, (Type*)0);
  M->getOrInsertFunction("LAMP_llvm_memcpy_p0i8_p0i8_i64", vty, i32, pi8, pi8, i64, (Type*)0);

  M->getOrInsertFunction("LAMP_llvm_memmove_p0i8_p0i8_i32", vty, i32, pi8, pi8, i32, (Type*)0);
  M->getOrInsertFunction("LAMP_llvm_memmove_p0i8_p0i8_i64", vty, i32, pi8, pi8, i64, (Type*)0);

  M->getOrInsertFunction("LAMP_llvm_memset_p0i8_i32", vty, i32, pi8, i8, i32, (Type*)0);
  M->getOrInsertFunction("LAMP_llvm_memset_p0i8_i64", vty, i32, pi8, i8, i64, (Type*)0);
  */

  M->getOrInsertFunction("LAMP_llvm_memcpy_p0i8_p0i8_i32", vty, i32, pi8, pi8, i32);
  M->getOrInsertFunction("LAMP_llvm_memcpy_p0i8_p0i8_i64", vty, i32, pi8, pi8, i64);

  M->getOrInsertFunction("LAMP_llvm_memmove_p0i8_p0i8_i32", vty, i32, pi8, pi8, i32);
  M->getOrInsertFunction("LAMP_llvm_memmove_p0i8_p0i8_i64", vty, i32, pi8, pi8, i64);

  M->getOrInsertFunction("LAMP_llvm_memset_p0i8_i32", vty, i32, pi8, i8, i32);
  M->getOrInsertFunction("LAMP_llvm_memset_p0i8_i64", vty, i32, pi8, i8, i64);
}

int LAMPProfiler::getIndex(Type* ty)
{
  int i = TD->getTypeSizeInBits(ty);
  switch (i)
  {
    case 8:
      return 0;  // load size 1 byte, function #0 or 4
    case 16:
      return 1;  // load size 2 bytes, function #1 or 5
    case 32:
      return 2;  // load size 4 bytes, function #2 or 6
    case 64:
      return 3;  // load size 8 bytes , function #3 or 7
    default:
      return 0;
  }
}

bool LAMPProfiler::runOnFunction(Function &F)
{
  Module* M = F.getParent();

  if(!GlobalCtorMap)
    constructGlobalCtors(M, &F);
/* This hack is no longer necessary; callBeforeMain was fixed in rev 58809.
  if(isGlobalCtor(&F))
    return true;
*/

  if (lampFuncs[0] == NULL)
  {
    createLampDeclarations(M);
  }


  // Correction just for PhysicsBench. This function is called before main function (LAMP_init). -PC 3/16/2009
  // Correction for specialized programs. - TO 12/06/2012
  if (F.getName().str() == "_GLOBAL__I_step_number" || F.getName().str() == "___tspec_destructor" ) {
    LLVM_DEBUG(errs() << "Skipping Function " << F.getName().str() << " beginning ID: " << instruction_id << '\n');
    return true;
  }



  LLVM_DEBUG(errs() << "\nInstrumenting Function " << F.getName().str() << " beginning ID: " << instruction_id << '\n');

  if (TD == NULL)
    TD = &M->getDataLayout();
#if defTLAMP
  if (lim == NULL)
    lim = &getAnalysis< LimitingInstModule >();
#endif

  if (PRINTID == "enable")
  {
    idout.open("lamp.id.out", ios_base::app);
    idout << "#Function " << F.getName().str() << "\n";
    //dbgs() << "#Function " << F.getName().str() << "\n";
  }

  unsigned iid = 0;
  for (Function::iterator IF = F.begin(), IE = F.end(); IF != IE; ++IF)
  {

    BasicBlock& BB = *IF;

    for (BasicBlock::iterator I = BB.begin(), E = BB.end(); I != E; ++I, ++iid)
    {

      // Instrument Loads
      if (isa<LoadInst>(I))
      {
        ++instruction_id;
        if (PRINTID == "enable")
        {
          idout << iid << " " << instruction_id << "\n";
          //dbgs() << instruction_id << ": load: " << *I << "\n";
        }
#if defTLAMP
        // tLAMP - only instrument required instructions
        CHECK_INST(I, lim)
        {
          LLVM_DEBUG(errs() << "tLAMP skipping inst: " << I << ":" << *I << "\n");
          continue;
        }
#endif
        std::vector<Value*> Args(2);

        Args[0] = ConstantInt::get(Type::getInt32Ty(M->getContext()), instruction_id);

        Value* ptr= (dyn_cast<LoadInst>(I))->getPointerOperand();
        Args[1] = new PtrToIntInst(ptr, Type::getInt64Ty(M->getContext()), "addr_var", &*I);

        /* TODO Is this load needed? */
        Value* v = new LoadInst(ptr, "value_var", &*I);
        int index = getIndex(v->getType());

        //Type* ptrb = cast<PointerType>(ptr->getType())->getElementType();
        //int index = getIndex(ptrb);

        // cerr << index << " " << *I  ; // DEBUG

        CallInst::Create(lampFuncs[index], Args, "", &*I);

      }
      // Instrument Stores
      else if (isa<StoreInst>(I))
      {
        ++instruction_id;
        if (PRINTID == "enable")
        {
          idout << iid << " " << instruction_id << "\n";
          //dbgs() << instruction_id << ": store: " << *I << "\n";
        }
#if defTLAMP
        // tLAMP - only instrument required instructions
        CHECK_INST(I, lim)
        {
          LLVM_DEBUG(errs() << "tLAMP skipping inst: " << I << ":" << *I << "\n");
          continue;
        }
#endif

        std::vector<Value*> Args(3);

        Args[0] = ConstantInt::get(Type::getInt32Ty(M->getContext()), instruction_id);

        Value* ptr= (dyn_cast<StoreInst>(I))->getPointerOperand();
        LLVM_DEBUG(errs() << ptr->getName().str() << "\n");
        Args[1] = new PtrToIntInst(ptr, Type::getInt64Ty(M->getContext()), "addr_var", &*I);

        Value* v = (dyn_cast<StoreInst>(I))->getOperand(0);
        Type*  Op_0_Type = v->getType();

        // fp ( cast to int64 )
        if(Op_0_Type->getTypeID() == Type::FloatTyID || Op_0_Type->getTypeID() == Type::DoubleTyID){
          Args[2]= new FPToSIInst(v, Type::getInt64Ty(M->getContext()), "value_var", &*I);
          // ptr (cast to int64)
        }else if(Op_0_Type->getTypeID() == Type::PointerTyID){
          Args[2]= new PtrToIntInst(v, Type::getInt64Ty(M->getContext()), "value_var", &*I);
          // int64
        }else if (Op_0_Type->isSized() && TD->getTypeSizeInBits(Op_0_Type) == 64){
          if(Op_0_Type->getTypeID() == Type::IntegerTyID)
            Args[2] = v;
          else // Some structure that is 64 bits, TODO treat this as an int so we get the real value
            Args[2] = ConstantInt::get(Type::getInt64Ty(M->getContext()), 42);
        }
        else if (Op_0_Type->getTypeID() == Type::VectorTyID) {
          // FIXME LAMP does not currently handle vector types here
          // Don't know to do for now, just pass 0
          Args[2] = ConstantInt::get(Type::getInt64Ty(M->getContext()), 0);
        }
        // int (sign extended to int64)
        else {
          // cerr << TD->getTypeSizeInBits(I->getOperand(0)->getType()) << " " << *(I->getOperand(0)->getType()) << '\n'; // DEBUG
          if(v->getType()->isSized() && TD->getTypeSizeInBits(v->getType()) <= 64)
            Args[2] = new SExtInst(v, Type::getInt64Ty(M->getContext()), "value_var", &*I);
          else
            continue;
        }

        //        int index = getIndex(Args[1]->getType()) + 4;     // CHECK
        // pochun : this might not be right. the type of varible should be used,
        // not the type of of pointer (casted to i64). The next line is the fix.
        int index = getIndex(Op_0_Type) + 4;
        // cerr << index << " " << *I  << '\n';  // DEBUG
        CallInst::Create(lampFuncs[index], Args, "", &*I);
      }
      else if( MemIntrinsic *mem = dyn_cast< MemIntrinsic >(I) )
      {
        //dbgs() << instruction_id+1 << ": memintrinsic: " << *I << "\n";
        CallSite cs(mem);
        const Function *callee = cs.getCalledFunction();
        if( callee->getName() == "llvm.memcpy.p0i8.p0i8.i32"
            ||  callee->getName() == "llvm.memcpy.p0i8.p0i8.i64"
            ||  callee->getName() == "llvm.memmove.p0i8.p0i8.i32"
            ||  callee->getName() == "llvm.memmove.p0i8.p0i8.i64"
            ||  callee->getName() == "llvm.memset.p0i8.i32"
            ||  callee->getName() == "llvm.memset.p0i8.i64" )
        {
          // good
        }
        else
        {
          assert(false && "Unknown memory intrinsic");
        }

#if defTLAMP
        // tLAMP - only instrument required instructions
        CHECK_INST(I, lim)
        {
          LLVM_DEBUG(errs() << "tLAMP skipping inst: " << I << ":" << *I << "\n");
          continue;
        }
#endif

        std::vector<Value*> Args;
        Args.push_back( ConstantInt::get(Type::getInt32Ty(M->getContext()), ++instruction_id) );
        Args.push_back( cs.getArgument(0) );
        Args.push_back( cs.getArgument(1) );
        Args.push_back( cs.getArgument(2) );

        std::string oldName = callee->getName();
        std::ostringstream newName;
        newName << "LAMP_";
        for(unsigned i=0; i<oldName.size(); ++i)
          if( oldName[i] == '.' )
            newName << '_';
          else
            newName << oldName[i];

        Function *fcn = M->getFunction( newName.str() );
        CallInst::Create(fcn, Args, "", &*I);
      }
      // Instrument external calls
      //      else if (isa<CallInst>(I) && ( (dyn_cast<CallInst>(I)->getCalledFunction() == NULL) ||
      //            (dyn_cast<CallInst>(I)->getCalledFunction()->isDeclaration())))

      else if ( EX_CALL(I))
      {
				// TODO
				// NPJ: there are several LLVM intrinsics which do not need
				// to be instrumented as external calls:
				//	llvm.lifetime.start, llvm.lifetime.end, llvm.uadd.with.overflow.i32

      // sot: remove Heejin's changes for malloc/free
      // allocation / deallocation handling
      // FIXME currently doesn't handle C++ new/delete
      //  CallInst *call = dyn_cast<CallInst>(I);

        /*
        Value *callee = dyn_cast<Function>(call->getCalledValue()->stripPointerCasts());
        string calleeName = callee ? callee->getName() : "";
        if (callee && calleeName.find("LAMP_") != 0) {
          //dbgs() << instruction_id+1 << ": ex_call: " << *I << "\n";
        */

        std::vector<Value*> Args(1);

        Args[0] = ConstantInt::get(Type::getInt32Ty(M->getContext()), ++instruction_id);

        CallInst::Create(CallFn, Args, "", &*I);

          /*
          if (callee->getName() == "malloc")
          {
            std::vector<Value*> Args(3);
            Args[0] = ConstantInt::get(Type::getInt32Ty(M->getContext()), 0);
            Args[1] = call;

            Value* size = call->getArgOperand(0);
            Value *tempval;
            if (size->getType()->getScalarSizeInBits() <
                Type::getInt64Ty(M->getContext())->getScalarSizeInBits())
              tempval = new SExtInst(size, Type::getInt64Ty(M->getContext()), "temp_var", &*I); // should be 32
            else
              tempval = size;

            Args[2] = new TruncInst(tempval, Type::getInt32Ty(M->getContext()), "size_var", &*I);

            //sot
            //CallInst::Create(AllocFn, Args, "", std::next(&*I));
            Instruction* cI = CallInst::Create(AllocFn, Args, "");
            cI->insertAfter(&*I);
          }
          */

          /*
          else if (callee->getName() == "free")
          {
            std::vector<Value*> Args(2);
            Args[0] = ConstantInt::get(Type::getInt32Ty(M->getContext()), 0);
            Args[1] = call->getArgOperand(0);
            CallInst::Create(DeallocFn, Args, "", &*I);
          }
        }
        */
      }

      /*      else if (isa<AllocationInst>(I))
              {
              std::vector<Value*> ListOfInst(10);
              int i = 0;

              while (isa<AllocaInst>(I))
              {
              ListOfInst[i] = I;
              i++;
              I++;
              }

              int i2;

      //cerr << *I << '\n';
      for (i2 = 0; i2 < i; i2++)
      {
      std::vector<Value*> Args(3);

      Args[0] = ConstantInt::get(Type::getInt32Ty(getGlobalContext()), 0);

      Value* tempaddr = new PtrToIntInst(ListOfInst[i2], Type::getInt64Ty(getGlobalContext()), "addr_var", I);
      Args[1] = new TruncInst(tempaddr, Type::getInt8Ty(getGlobalContext()), "addr_var", I);

      Value* size = (dyn_cast<AllocationInst>)(ListOfInst[i2])->getArraySize();
      Value* tempval = new SExtInst(size, Type::getInt64Ty(getGlobalContext()), "temp_var", I); // should be 32

      Args[2] = new TruncInst(tempval, Type::getInt32Ty(getGlobalContext()), "size_var", I);

      CallInst::Create(AllocFn, Args, "", I);
      }
      // possibly insert LAMP_allocate call here -- u32 lampID, void * memory, size_t size
      }
      else if (isa<FreeInst>(I))
      {

      std::vector<Value*> Args(3);

      Args[0] = ConstantInt::get(Type::getInt32Ty(getGlobalContext()), 0);

      //Value* ptr= (III.getOperand(0));
      //Type *SrcTy = ptr->getType();
      //LLVM_DEBUG(errs() << "Source: " << *SrcTy);
      //Args[1] = new SExtInst(ptr, Type::getInt32Ty(getGlobalContext()), "addr_var", I);

      Value* tempaddr = new PtrToIntInst(I, Type::getInt64Ty(getGlobalContext()), "taddr_var", I);
      Args[1] = new TruncInst(tempaddr, Type::getInt8Ty(getGlobalContext()), "addr_var", I);

      Value* size = (dyn_cast<AllocationInst>)(I)->getArraySize();
      Value* tempval = new SExtInst(size, Type::getInt64Ty(getGlobalContext()), "temp_var", I);  // should be 32

      Args[2] = new TruncInst(tempval, Type::getInt32Ty(getGlobalContext()), "size_var", I);

      CallInst::Create(DeallocFn, Args, "", I);
      LLVM_DEBUG(errs() << instruction_id << *I);

      // possibly insert LAMP_deallocate call here -- u32 lampID, void * memory, size_t size
      }*/
    }
  }

  LLVM_DEBUG(errs() << "Instrumentation of " << F.getName().str() << " complete.  Ending ID: " << instruction_id << '\n');

  if (PRINTID == "enable")
  {
    idout.close();
  }

  return true;
}

// This class retrieves data from the LdStCallCounter class.  While not explicitly noted for llvm structural
// reasons, this class does require that insert-lamp-loop-profiling (LAMPLoopProfiler class) run first.  If it
// fails to run first, the number of loops will be reported as zero.  Initialization pass should be run LAST.
namespace {
  class LAMPInit : public ModulePass {
    bool runOnModule(Module& M);

    public:
    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
      AU.addRequired<LdStCallCounter>();
#if defTLAMP
      AU.addPreserved< LimitingInstModule >();
#endif
      //  AU.addRequired<LAMPLoopProfiler>();  LAMPLoopProfiler MUST run first but we cannot add required due to
    }            // LLVM structural issues

    static char ID;
    LAMPInit() : ModulePass(ID)
    { }
  };
}

char LAMPInit::ID = 0;

static cl::opt<std::string> InitFunctionName("lamp-init-fn", cl::init("main"), cl::NotHidden, cl::desc("Initialization call must be first function"));

static RegisterPass<LAMPInit> RP10("insert-lamp-init", "Insert initialization for LAMP profiling", false, false);

ModulePass *llvm::createLAMPInitPass() { return new LAMPInit(); }

bool LAMPInit::runOnModule(Module& M)
{
  for(Module::iterator IF = M.begin(), E = M.end(); IF != E; ++IF)
  {
    Function& F = *IF;
    if (F.getName().str() == InitFunctionName) {
      const char* FnName = "LAMP_init";

      LdStCallCounter& lscnts = getAnalysis<LdStCallCounter>();

      unsigned int cnt = lscnts.getCountInsts();
      unsigned int lps = lscnts.num_loops;

      LLVM_DEBUG(errs() << "LAMP-- Ld/St/Intrinsic/Call Count:" << cnt << " Loop Count:" << lps <<'\n');

      Constant *InitFn = M.getOrInsertFunction(FnName,
          Type::getVoidTy(M.getContext()),
          Type::getInt32Ty(M.getContext()),
          Type::getInt32Ty(M.getContext()),
          Type::getInt64Ty(M.getContext()),
          Type::getInt64Ty(M.getContext()));
          //(Type *)0);   //sot

      std::vector<Value*> Args(4);
      Args[0] = ConstantInt::get(Type::getInt32Ty(M.getContext()), cnt, false);
      Args[1] = ConstantInt::get(Type::getInt32Ty(M.getContext()), lps, false);
      Args[2] = ConstantInt::get(Type::getInt64Ty(M.getContext()), 1, false);
      Args[3] = ConstantInt::get(Type::getInt64Ty(M.getContext()), 0, false);

      BasicBlock& entry = F.getEntryBlock();
      BasicBlock::iterator InsertPos = entry.begin();
      while (isa<AllocaInst>(InsertPos)) ++InsertPos;

#if 0
      CallInst::Create(InitFn, Args, "", InsertPos);
#else
      /* Need to make sure LAMP_init runs first so we create a global constructor function
       * (lamp_initor) which calls LAMP_init and set it's priority to max. Then we
       * reduce all other GlobalCtors priority by 1
       *
       * This destroys profiling data, so we can't use it
       * (-sbeard, rev 50667)
       *    Does it?
       *    GlobalCtors was fixed in 58809, so we can ensure that
       *    the initializer runs before every other global ctor.
       *    How does it destroy profiling data?
       *    Is it just because some global variables (with
       *    corresponding global constructors) were
       *    added to liblamp_hooks.a in 46708?
       *    - NPJ, 17 Oct 2013.
       */


      // Create the GlobalCtor function
      std::vector<Type*>FuncTy_0_args;
      FunctionType* FuncTy_0 = FunctionType::get(
          /*Result=*/Type::getVoidTy( M.getContext() ),
          /*Params=*/FuncTy_0_args,
          /*isVarArg=*/false);

      Function* func_lamp_initor = Function::Create(
          /*Type=*/FuncTy_0,
          /*Linkage=*/GlobalValue::ExternalLinkage,
          /*Name=*/"lamp_initor", &M);

      BasicBlock *initor_entry = BasicBlock::Create(M.getContext(), "entry", func_lamp_initor,0);
      CallInst::Create(InitFn, Args, "", initor_entry);
      ReturnInst::Create(M.getContext(), initor_entry);

      // Function has been created, now add it to the global ctor list
      callBeforeMain(func_lamp_initor, 1);
#endif


      return true;
    }

  }
  return false;
}









    // Loop instrumentation class instruments loops with invocation, iteration beginning, iteration ending
    // and loop exiting calls.  It also counts the number of loops for use by LAMPProfiler initilization.
    namespace {
      class LAMPLoopProfiler : public LoopPass {
        bool runOnLoop (Loop *Lp, LPPassManager &LPM);

        virtual void getAnalysisUsage(AnalysisUsage &AU) const {
#if defTLAMP
          AU.addRequired< LimitingInstModule >();
#endif
          AU.addRequiredTransitive<LdStCallCounter>();
          AU.addPreserved< LdStCallCounter >();
#if defTLAMP
          AU.addPreserved< LimitingInstModule >();
#endif
          //AU.addRequired<LAMPProfiler>();  For reasons incomprehensible to us, this is not permissible
         // AU.addRequired<LimitingInst>();

        }

        unsigned int numLoops;      // numLoops for LAMPProfiler initilization
#if defTLAMP
        LimitingInstModule *lim;
#endif

        public:
        bool doInitialization(Loop *Lp, LPPassManager &LPM) { return false; }
        static char ID;
        static bool IDInitFlag;
        static unsigned int loop_id;    // ids will be progressive starting after instruction ids

        std::ofstream loopsout;

        LAMPLoopProfiler() : LoopPass(ID)
        {
          numLoops = 0;
#if defTLAMP
          lim = NULL;
#endif
        }
        unsigned int getNumLoops(){ return numLoops;}
      };
    }

    char LAMPLoopProfiler::ID = 0;
    bool LAMPLoopProfiler::IDInitFlag = false;
    unsigned int LAMPLoopProfiler::loop_id = 0;

    static RegisterPass<LAMPLoopProfiler> RP5("insert-lamp-loop-profiling", "Insert instrumentation for LAMP loop profiling", false, false);

    static cl::opt<std::string> LAMPVIEW("lamp-view-switch", cl::init("disable"), cl::NotHidden, cl::desc("To enable LAMPView output send enable"));

    LoopPass *llvm::createLAMPLoopProfilerPass() { return new LAMPLoopProfiler(); }


    bool isaLAMP(Instruction *inst)
    {
      if(isa<CallInst>(inst) || isa<InvokeInst>(inst))
      {
        CallSite call = CallSite(inst);
        Function *f = call.getCalledFunction();
        if( f != NULL)
        {
          std::string cname = f->getName();
          if( cname.find("LAMP") != std::string::npos)
          {
            return true;
          }
        }
      }
      return false;
    }

    bool isBeginInvoc(Instruction *inst)
    {
      if(isa<CallInst>(inst) || isa<InvokeInst>(inst))
      {
        CallSite call = CallSite(inst);
        Function *f = call.getCalledFunction();
        if( f != NULL)
        {
          std::string cname = f->getName();
          if( cname.find("LAMP_loop_invocation") != std::string::npos)
          {
            return true;
          }
        }
      }
      return false;
    }


    bool LAMPLoopProfiler::runOnLoop(Loop *Lp, LPPassManager &LPM) {
      BasicBlock *preHeader;
      BasicBlock *header;
      BasicBlock *latch;

      header = Lp->getHeader();
      preHeader = Lp->getLoopPreheader();
      latch = Lp->getLoopLatch();

      // Correction for specialized programs. - TO 12/06/2012
      if (header->getParent()->getName().str() == "___tspec_destructor")
        return true;



      LdStCallCounter& lscnts = getAnalysis<LdStCallCounter>();

      if(!IDInitFlag)
      {
        if(LAMPVIEW == "enable"){
          loopsout.open("loops.out");
          loopsout << "#File generated by LAMPLoopProfiler pass\n";
          loopsout << "#LAMP_Loop_ID Line_Number Function_Name BB_Name\n";
        }
        loop_id = 0;//lscnts.getCountInsts()-1;  // first id will begin after instruction ids
        IDInitFlag = true;
      }
      // else
      //        return true;

      SmallVector<BasicBlock*, 8> exitBlocks;      // assuming max 8 exit blocks.  Is this wise?
      // TRM 7/24/08 removed exiting blocks instrumentation
      // in favor of placing iter end prior loop exit

      Lp->getExitBlocks(exitBlocks);

      Module *M = (header->getParent())->getParent();

      numLoops++;

      lscnts.num_loops = numLoops;

#if defTLAMP
      if(TLAMP)
      {
        if (lim == NULL)
          lim = &getAnalysis< LimitingInstModule >();

        if (!lim->isLoopLimiting(header->getName()))
        {
          LLVM_DEBUG(errs() << "Loop " << header->getName() << " is not limiting\n");
          //errs() << "Loop " << header->getName() << " is not limiting\n";
          ++loop_id;
          return false;
        }
      }
#endif

      // insert invocation function at end of preheader (called once prior to loop)
      const char* InvocName = "LAMP_loop_invocation";
      //Constant *InvocFn = M->getOrInsertFunction(InvocName, Type::getVoidTy(M->getContext()), Type::getInt32Ty(M->getContext()), (Type *)0);
      Constant *InvocFn = M->getOrInsertFunction(InvocName, Type::getVoidTy(M->getContext()), Type::getInt32Ty(M->getContext()));
      std::vector<Value*> Args(1);
      Args[0] = ConstantInt::get(Type::getInt32Ty(M->getContext()), ++loop_id);
      //dbgs() << "Loop: ID = " << loop_id << " Header = " << header->getName() << "\n";


      assert(preHeader && "Null preHeader -- Did you run loopsimplify?");

      if (!preHeader->empty()){
        if(LAMPVIEW == "enable"){
          const DebugLoc & DSI = (preHeader->getTerminator())->getDebugLoc();  // line translation TRM
          if (DSI)
          {

            loopsout << loop_id << " " << DSI.getLine()<< " " << preHeader->getParent()->getName().str() << " " << preHeader->getName().str()
              << " " << preHeader->getTerminator()->getSuccessor(0)->getName().str()  << "\n";
          }
          else
          {
            const DebugLoc &DSI2 = (preHeader->getTerminator()->getSuccessor(0)->getTerminator())->getDebugLoc();
            if(DSI2)
              loopsout << loop_id << " " << DSI2.getLine() << " " << preHeader->getParent()->getName().str() << " " << preHeader->getName().str()
                << " " << preHeader->getTerminator()->getSuccessor(0)->getName().str() << " (no debugLoc)\n";
            else
              loopsout << loop_id << " 0 " << preHeader->getParent()->getName().str() << " " << preHeader->getName().str()
                << " " << preHeader->getTerminator()->getSuccessor(0)->getName().str() << " (no debugLoc2)\n";
          }
        }
        CallInst::Create(InvocFn, Args, "", (preHeader->getTerminator()));
      }
      else
      {
        if(LAMPVIEW == "enable"){
          loopsout << loop_id << " 0 " << preHeader->getParent()->getName().str() << " (empty)\n";
        }
        CallInst::Create(InvocFn, Args, "", (preHeader));
      }


      // insert iteration begin function at beginning of header (called each loop)
      const char* IterBeginName = "LAMP_loop_iteration_begin";
      //sot
      //Constant *IterBeginFn = M->getOrInsertFunction(IterBeginName, Type::getVoidTy(M->getContext()), (Type *)0);
      Constant *IterBeginFn = M->getOrInsertFunction(IterBeginName, Type::getVoidTy(M->getContext()));
      CallInst::Create(IterBeginFn, "", &*(header->getFirstInsertionPt()));

      // insert iteration at cannonical backedge.  exiting block insertions removed in favor of exit block
      const char* IterEndName = "LAMP_loop_iteration_end";
      //sot
      //Constant *IterEndFn = M->getOrInsertFunction(IterEndName, Type::getVoidTy(M->getContext()), (Type *)0);
      Constant *IterEndFn = M->getOrInsertFunction(IterEndName, Type::getVoidTy(M->getContext()));

      // cannonical backedge
      if (!latch->empty())
        CallInst::Create(IterEndFn, "", (latch->getTerminator()));
      else
        CallInst::Create(IterEndFn, "", (latch));


      // insert loop end at beginning of exit blocks
      // Loop simplify guarantees that exit blocks are only reachable from the loop
      const char* LoopEndName = "LAMP_loop_exit";
      //Constant *LoopEndFn = M->getOrInsertFunction(LoopEndName, Type::getVoidTy(M->getContext()), (Type *)0);
      //const char* LoopEndName = "LAMP_loop_exit2";
      //Constant *LoopEndFn= M->getOrInsertFunction(LoopEndName, Type::getVoidTy(M->getContext()), Type::getInt32Ty(M->getContext()), (Type *)0);
      Constant *LoopEndFn= M->getOrInsertFunction(LoopEndName, Type::getVoidTy(M->getContext()), Type::getInt32Ty(M->getContext()));
      //std::vector<Value*> Args2(1);
      //Args2[0] = ConstantInt::get(Type::getInt32Ty(M->getContext()), loop_id);


      set <BasicBlock*> BBSet;
      BBSet.clear();
      for(unsigned int i = 0; i != exitBlocks.size(); i++){
        // this ordering places iteration end before loop exit
        // make sure not inserting the same exit block more than once for a loop -PC 2/5/2009
        if (BBSet.find(exitBlocks[i])!=BBSet.end()) continue;
        BBSet.insert(exitBlocks[i]);
        BasicBlock::iterator ii = exitBlocks[i]->getFirstInsertionPt();  // exitBlocks[i]->begin();
        // Skip the LAMP and invoc instructions so we exit in the correct order
        while (isaLAMP(&*ii) && !isBeginInvoc(&*ii) ) { ii++; }

        CallInst::Create(IterEndFn, "", &*ii);  // iter end placed before exit call

        CallInst::Create(LoopEndFn, Args, "", &*ii);
        //CallInst::Create(LoopEndFn, "", ii);  // loop exiting
      }

      LLVM_DEBUG(errs() << "Num Loops Processed: " << numLoops << "  Loop ID: " << loop_id << '\n');

      return true;

    }
#undef DEBUG_TYPE
